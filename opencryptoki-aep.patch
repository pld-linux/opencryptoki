--- opencryptoki-2.4/usr/lib/pkcs11/aep_stdll/aeptok_api.c.orig	2011-05-18 00:27:00.000000000 +0200
+++ opencryptoki-2.4/usr/lib/pkcs11/aep_stdll/aeptok_api.c	2011-06-19 20:39:06.422327697 +0200
@@ -34,6 +34,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <string.h>
+
+#include "pkcs11types.h"
+#include "defs.h"
+#include "host_defs.h"
+#include "h_extern.h"
 
 #include "aeptok_api.h"
 
--- opencryptoki/usr/lib/pkcs11/aep_stdll/aeptok_specific.c.orig	2013-07-15 19:25:40.000000000 +0200
+++ opencryptoki/usr/lib/pkcs11/aep_stdll/aeptok_specific.c	2013-12-30 22:59:58.222059030 +0100
@@ -14,7 +14,6 @@
 #include "defs.h"
 #include "host_defs.h"
 #include "h_extern.h"
-#include "args.h"
 #include "errno.h"
 #include "tok_specific.h"
 
@@ -49,13 +48,13 @@ int cryptoki_aep_avail = TRUE;
 static int max_key_len = 2176;
 
 CK_RV
-token_specific_session(CK_SLOT_ID  slotid)
+token_specific_open_session(SESSION *session)
 {
 	return CKR_OK;
 }
 
 CK_RV
-token_rng(CK_BYTE *output, CK_ULONG bytes)
+token_specific_rng(CK_BYTE *output, CK_ULONG bytes)
 {
 #if 0
 	int bytes2 = 384;
@@ -97,19 +96,19 @@ tok_slot2local(CK_SLOT_ID snum)
 
 
 CK_RV
-token_specific_init(char * Correlator,CK_SLOT_ID SlotNumber)
+token_specific_init(char * Correlator,CK_SLOT_ID SlotNumber,char * conf_name)
 {
 	return CKR_OK;
 }
 
 CK_RV
-token_specific_final()
+token_specific_final(void)
 {
 	return CKR_OK;
 }
 
 CK_RV
-token_specific_des_key_gen(CK_BYTE  *des_key,CK_ULONG len)
+token_specific_des_key_gen(CK_BYTE  *des_key,CK_ULONG len,CK_ULONG keysize)
 {
       
 	// Nothing different to do for DES or TDES here as this is just
@@ -127,10 +126,11 @@ token_specific_des_ecb(CK_BYTE * in_data
                        CK_ULONG in_data_len,
                        CK_BYTE *out_data,
                        CK_ULONG *out_data_len,
-                       CK_BYTE  *key_value,
+                       OBJECT  *key,
                        CK_BYTE  encrypt)
 {
 	CK_ULONG       rc;
+	CK_ATTRIBUTE *attr = NULL;
 	
 	des_key_schedule des_key2;
    	const_des_cblock key_val_SSL, in_key_data;
@@ -138,8 +138,14 @@ token_specific_des_ecb(CK_BYTE * in_data
 	int i,j;
    	int ret;
 
+	// get the key value
+	if (template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+
   	// Create the key schedule
-	memcpy(&key_val_SSL, key_value, 8);
+	memcpy(&key_val_SSL, attr->pValue, 8);
 	des_set_key_unchecked(&key_val_SSL, des_key2);
 
 	// the des decrypt will only fail if the data length is not 
@@ -181,11 +187,12 @@ token_specific_des_cbc(CK_BYTE * in_data
                        CK_ULONG in_data_len,
                        CK_BYTE *out_data,
                        CK_ULONG *out_data_len,
-                       CK_BYTE  *key_value, 
+                       OBJECT  *key, 
                        CK_BYTE *init_v,
                        CK_BYTE  encrypt)
 {
 	CK_ULONG         rc;
+	CK_ATTRIBUTE *attr = NULL;
 	
 	des_cblock ivec;
 	int ret;
@@ -194,8 +201,14 @@ token_specific_des_cbc(CK_BYTE * in_data
    	const_des_cblock key_val_SSL, in_key_data;
 	des_cblock out_key_data;
 
+	// get the key value
+	if (template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+
 	// Create the key schedule
-	memcpy(&key_val_SSL, key_value, 8);
+	memcpy(&key_val_SSL, attr->pValue, 8);
    	des_set_key_unchecked(&key_val_SSL, des_key2);
    
 	memcpy(&ivec, init_v, 8);
@@ -225,10 +238,13 @@ token_specific_tdes_ecb(CK_BYTE * in_dat
 			CK_ULONG in_data_len,
 			CK_BYTE *out_data,
 			CK_ULONG *out_data_len,
-			CK_BYTE  *key_value,
+			OBJECT   *key,
 			CK_BYTE  encrypt)
 {
 	CK_RV  rc;
+	CK_ATTRIBUTE *attr = NULL;
+	CK_KEY_TYPE keytype;
+	CK_BYTE key_value[3*DES_KEY_SIZE];
 	
 	int k,j, ret;
 	des_cblock out_temp;
@@ -239,6 +255,25 @@ token_specific_tdes_ecb(CK_BYTE * in_dat
    	const_des_cblock key_SSL1, key_SSL2, key_SSL3, in_key_data;
 	des_cblock out_key_data;
 
+	// get the key type
+	rc = template_attribute_find(key->template, CKA_KEY_TYPE, &attr);
+	if (rc == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+	keytype = *(CK_KEY_TYPE *)attr->pValue;
+
+	// get the key value
+	if (template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+	if (keytype == CKK_DES2) {
+		memcpy(key_value, attr->pValue, 2*DES_KEY_SIZE);
+		memcpy(key_value + (2*DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);
+	} else
+		memcpy(key_value, attr->pValue, 3*DES_KEY_SIZE);
+
 	// The key as passed is a 24 byte long string containing three des keys
 	// pick them apart and create the 3 corresponding key schedules
 	memcpy(&key_SSL1, key_value, 8);
@@ -291,12 +326,16 @@ token_specific_tdes_cbc(CK_BYTE * in_dat
                        CK_ULONG in_data_len,
                        CK_BYTE *out_data,
                        CK_ULONG *out_data_len,
-                       CK_BYTE  *key_value, 
+                       OBJECT  *key, 
                        CK_BYTE *init_v,
                        CK_BYTE  encrypt)
 {
 
 	CK_RV rc = CKR_OK;
+	CK_ATTRIBUTE *attr = NULL;
+	CK_KEY_TYPE keytype;
+	CK_BYTE key_value[3*DES_KEY_SIZE];
+
 	des_key_schedule des_key1;
 	des_key_schedule des_key2;
 	des_key_schedule des_key3;
@@ -304,6 +343,25 @@ token_specific_tdes_cbc(CK_BYTE * in_dat
    	const_des_cblock key_SSL1, key_SSL2, key_SSL3, in_key_data;
 	des_cblock ivec;
 
+	// get the key type
+	rc = template_attribute_find(key->template, CKA_KEY_TYPE, &attr);
+	if (rc == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+	keytype = *(CK_KEY_TYPE *)attr->pValue;
+
+	// get the key value
+	if (template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+	if (keytype == CKK_DES2) {
+		memcpy(key_value, attr->pValue, 2*DES_KEY_SIZE);
+		memcpy(key_value + (2*DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);
+	} else
+		memcpy(key_value, attr->pValue, 3*DES_KEY_SIZE);
+
 	// The key as passed in is a 24 byte string containing 3 keys
 	// pick it apart and create the key schedules
 	memcpy(&key_SSL1, key_value, 8);
@@ -829,12 +887,18 @@ CK_RV
 token_specific_rsa_encrypt( CK_BYTE   * in_data,
 			    CK_ULONG    in_data_len,
 			    CK_BYTE   * out_data,
+			    CK_ULONG  * out_data_len,
 			    OBJECT    * key_obj )
 {
 	CK_RV rc;
 	RSA *rsa;
 	int mLen;
 	
+	if (in_data_len > *out_data_len) {
+		OCK_LOG_DEBUG("CKR_DATA_LEN_RANGE\n");
+		return CKR_DATA_LEN_RANGE;
+	}
+
 	// Convert the local representation to an RSA representation
 	rsa = (RSA *)rsa_convert_public_key(key_obj, &mLen);
 	if (rsa==NULL) {
@@ -862,6 +926,7 @@ token_specific_rsa_encrypt( CK_BYTE   *
 	}
 	
 	if (rc != 0) {
+		*out_data_len = in_data_len;
 		rc = CKR_OK;
 	} else {
 		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
@@ -879,12 +944,18 @@ CK_RV
 token_specific_rsa_decrypt( CK_BYTE   * in_data,
 			    CK_ULONG    in_data_len,
 			    CK_BYTE   * out_data,
+			    CK_ULONG  * out_data_len,
 			    OBJECT    * key_obj )
 {
 	CK_RV  rc;
 	RSA   *rsa;
 	int mLen;
 
+	if (*out_data_len < in_data_len) {
+		OCK_LOG_ERR(ERR_BUFFER_TOO_SMALL);
+		return CKR_BUFFER_TOO_SMALL;
+	}
+
 	// Convert the local key representation to an RSA key representaion
 	rsa = (RSA *)rsa_convert_private_key(key_obj, &mLen);
 	if (rsa == NULL) {
@@ -910,6 +981,7 @@ token_specific_rsa_decrypt( CK_BYTE   *
 					 rsa, RSA_NO_PADDING);
 	}
 	if (rc != 0) {
+		*out_data_len = in_data_len;
 		rc = CKR_OK;
 	} else {
 		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
@@ -925,7 +997,7 @@ token_specific_rsa_decrypt( CK_BYTE   *
 #ifndef NOAES
 
 CK_RV
-token_specific_aes_key_gen( CK_BYTE *key, CK_ULONG len )
+token_specific_aes_key_gen( CK_BYTE *key, CK_ULONG len, CK_ULONG keysize )
 {
         return rng_generate(key, len);
 }
@@ -935,22 +1007,28 @@ token_specific_aes_ecb( CK_BYTE
                         CK_ULONG        in_data_len,
                         CK_BYTE         *out_data,
                         CK_ULONG        *out_data_len,
-                        CK_BYTE         *key_value,
-                        CK_ULONG        key_len,
+                        OBJECT          *key,
                         CK_BYTE         encrypt)
 {
+	CK_ATTRIBUTE *attr = NULL;
         AES_KEY         ssl_aes_key;
         int             i;
         /* There's a previous check that in_data_len % AES_BLOCK_SIZE == 0,
          * so this is fine */
         CK_ULONG        loops = (CK_ULONG)(in_data_len/AES_BLOCK_SIZE);
 
+	// get the key value
+	if (template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+
         memset( &ssl_aes_key, 0, sizeof(AES_KEY));
 
         // AES_ecb_encrypt encrypts only a single block, so we have to break up the
         // input data here
         if (encrypt) {
-                AES_set_encrypt_key((unsigned char *)key_value, (key_len*8), &ssl_aes_key);
+                AES_set_encrypt_key((unsigned char *)attr->pValue, (attr->ulValueLen*8), &ssl_aes_key);
                 for( i=0; i<loops; i++ ) {
                         AES_ecb_encrypt((unsigned char *)in_data + (i*AES_BLOCK_SIZE),
                                         (unsigned char *)out_data + (i*AES_BLOCK_SIZE),
@@ -958,7 +1036,7 @@ token_specific_aes_ecb( CK_BYTE
                                         AES_ENCRYPT);
                 }
         } else {
-                AES_set_decrypt_key((unsigned char *)key_value, (key_len*8), &ssl_aes_key);
+                AES_set_decrypt_key((unsigned char *)attr->pValue, (attr->ulValueLen*8), &ssl_aes_key);
                 for( i=0; i<loops; i++ ) {
                         AES_ecb_encrypt((unsigned char *)in_data + (i*AES_BLOCK_SIZE),
                                         (unsigned char *)out_data + (i*AES_BLOCK_SIZE),
@@ -976,25 +1054,31 @@ token_specific_aes_cbc( CK_BYTE
                         CK_ULONG        in_data_len,
                         CK_BYTE         *out_data,
                         CK_ULONG        *out_data_len,
-                        CK_BYTE         *key_value,
-                        CK_ULONG        key_len,
+                        OBJECT          *key,
                         CK_BYTE         *init_v,
                         CK_BYTE         encrypt)
 {
         AES_KEY         ssl_aes_key;
+	CK_ATTRIBUTE *attr = NULL;
         int             i;
 
+	// get the key value
+	if(template_attribute_find(key->template, CKA_VALUE, &attr) == FALSE) {
+		OCK_LOG_ERR(ERR_FUNCTION_FAILED);
+		return CKR_FUNCTION_FAILED;
+	}
+
         memset( &ssl_aes_key, 0, sizeof(AES_KEY));
 
         // AES_cbc_encrypt chunks the data into AES_BLOCK_SIZE blocks, unlike
         // AES_ecb_encrypt, so no looping required.
         if (encrypt) {
-                AES_set_encrypt_key((unsigned char *)key_value, (key_len*8), &ssl_aes_key);
+                AES_set_encrypt_key((unsigned char *)attr->pValue, (attr->ulValueLen*8), &ssl_aes_key);
                 AES_cbc_encrypt((unsigned char *)in_data, (unsigned char *)out_data,
                                 in_data_len,              &ssl_aes_key,
                                 init_v,                   AES_ENCRYPT);
         } else {
-                AES_set_decrypt_key((unsigned char *)key_value, (key_len*8), &ssl_aes_key);
+                AES_set_decrypt_key((unsigned char *)attr->pValue, (attr->ulValueLen*8), &ssl_aes_key);
                 AES_cbc_encrypt((unsigned char *)in_data, (unsigned char *)out_data,
                                 in_data_len,              &ssl_aes_key,
                                 init_v,                   AES_DECRYPT);
--- opencryptoki/usr/lib/pkcs11/aep_stdll/tok_struct.h.orig	2013-07-15 19:25:40.000000000 +0200
+++ opencryptoki/usr/lib/pkcs11/aep_stdll/tok_struct.h	2013-12-30 23:06:15.798709893 +0100
@@ -310,26 +310,91 @@
 token_spec_t token_specific  = {
      AEP_CONFIG_PATH,
      "aep",
-     "AEP_STDLL_Debug",
+     0,
+     {
+	     FALSE,
+	     FALSE,
+	     CKM_DES3_CBC,
+	     "12345678",
+	     "10293847"
+     },
+     NULL, /* creatlock */
+     NULL, /* attach_shm */
      &token_specific_init,
+     NULL, /* init_token_data */
+     NULL, /* load_token_data */
+     NULL, /* save_token_data */
      &tok_slot2local,
-     &token_rng,
-     &token_specific_session,
+     &token_specific_rng,
+     &token_specific_open_session,
+     NULL, /* close_session */
      &token_specific_final,
+     NULL, /* init_token */
+     NULL, /* login */
+     NULL, /* logout */
+     NULL, /* init_pin */
+     NULL, /* set_pin */
+     NULL, /* copy object */
+     NULL, /* create_object */
+     NULL, /* get_attribute_value */
+     NULL, /* set_attribute_value */
+     NULL, /* find_objects_init */
+     NULL, /* destroy_object */
+     NULL, /* generate_key */
+     NULL, /* generate_key_pair */
+     NULL, /* encrypt_init */
+     NULL, /* encrypt */
+     NULL, /* encrypt_update */
+     NULL, /* encrypt_final */
+     NULL, /* decrypt_init */
+     NULL, /* decrypt */
+     NULL, /* decrypt_update */
+     NULL, /* decrypt_final */
+     NULL, /* derive_key */
+     NULL, /* wrap_key */
+     NULL, /* unwrap_key */
+     NULL, /* sign_init */
+     NULL, /* sign */
+     NULL, /* sign_update */
+     NULL, /* sign_final */
+     NULL, /* verify_init */
+     NULL, /* verify */
+     NULL, /* verify_update */
+     NULL, /* verify_final */
+
      &token_specific_des_key_gen,
      &token_specific_des_ecb,
      &token_specific_des_cbc,
 
      &token_specific_tdes_ecb,
      &token_specific_tdes_cbc,
-
+     NULL, /* tdes_ofb */
+     NULL, /* tdes_cfb */
+     NULL, /* tdes_mac */
 
      &token_specific_rsa_decrypt,
      &token_specific_rsa_encrypt,
+     NULL, /* rsa_sign */
+     NULL, /* rsa_verify */
+     NULL, /* rsa_verify_recover */
+     NULL, /* rsa_x509_decrypt */
+     NULL, /* rsa_x509_encrypt */
+     NULL, /* rsa_x509_sign */
+     NULL, /* rsa_x509_verify */
+     NULL, /* rsa_x509_verify_recover */
      &token_specific_rsa_generate_keypair,
+
+     NULL, /* ec_sign */
+     NULL, /* ec_verify */
+     NULL, /* ec_generate_keypair */
      // DH
+#ifndef NODH
      &token_specific_dh_pkcs_derive,
      &token_specific_dh_pkcs_key_pair_gen,
+#else
+     NULL,
+     NULL,
+#endif
      // SHA1
      NULL,
      NULL,
@@ -346,15 +411,29 @@ token_spec_t token_specific  = {
      NULL,
      NULL,
      NULL,
-#ifndef NOAES
      // AES
+#ifndef NOAES
      &token_specific_aes_key_gen,
      &token_specific_aes_ecb,
      &token_specific_aes_cbc,
+#else
+     NULL,
+     NULL,
      NULL,
 #endif
+     NULL,
+
+     NULL, /* t_aes_ofb */
+     NULL, /* t_aes_cfb */
+     NULL, /* t_aes_mac */
+
+     NULL, /* dsa_generate_keypair */
+     NULL, /* dsa_sign */
+     NULL, /* dsa_verify */
+
      &token_specific_get_mechanism_list,
-     &token_specific_get_mechanism_info
+     &token_specific_get_mechanism_info,
+     NULL /* object_add */
 };
 
 #endif
